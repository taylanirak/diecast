6.2 Deployment Stages
Structured Deployment Flow (hyphen based)
Stage 1: Build and Test (GitHub Actions)
- Checkout source code (approximately 30 seconds)
- Setup Node.js and pnpm (approximately 20 seconds)
- Install dependencies using cache (approximately 40 seconds)
- Run linting across all packages (approximately 15 seconds)
- Run type checks (approximately 20 seconds)
- Execute unit tests (approximately 30 seconds)
- Execute end-to-end tests for critical flows (approximately 2 minutes)
- Build Docker images in parallel (approximately 3 minutes)
- Total stage duration: approximately 6 to 7 minutes
Stage 2: Push Images (GitHub Actions)
- Authenticate with GitHub Container Registry (approximately 5 seconds)
- Tag Docker images with commit SHA and latest tag (approximately 5 seconds)
- Push images to registry in parallel (approximately 2 minutes)
- Total stage duration: approximately 2 minutes
Stage 3: Deploy (Coolify)
- Receive deployment webhook (approximately 1 second)
- Pull new Docker images (approximately 1 minute)
- Run database migrations (approximately 10 seconds)
- Start new containers (blue environment) (approximately 20 seconds)
- Wait for health checks to pass (approximately 30 seconds)
- Switch traffic from blue to green environment (approximately 5 seconds)
- Stop old containers (approximately 10 seconds)
- Total stage duration: approximately 2 to 3 minutes
Total Deployment Time
- Approximately 10 to 12 minutes end to end
Plain Text Explanation
The deployment process is divided into three clearly defined stages to ensure reliability, speed, and zero
downtime. The first stage focuses on build and test activities executed by GitHub Actions. During this
stage, the codebase is validated through linting, type checking, unit tests, and end-to-end tests, followed
by parallel Docker image builds. The second stage handles image publishing. Successfully built images
are authenticated, tagged, and pushed to the GitHub Container Registry in parallel, minimizing the time
required to make artifacts available for deployment. The final stage is managed by Coolify and is
responsible for deploying the new release. Coolify pulls the latest images, applies database migrations,
and performs a blue-green deployment. Traffic is switched only after health checks succeed, ensuring zero
downtime. Old containers are terminated once the new version is fully live. The entire process completes
within a predictable and controlled deployment window.